(function () {
  const DEFAULT_API_BASE = "";

  const CONFIG = {
    apiBase:
      (window.MISSIONCANVAS_CONFIG && window.MISSIONCANVAS_CONFIG.apiBase) ||
      DEFAULT_API_BASE,
    routePath: "/v1/missioncanvas/route",
    confirmPath: "/v1/missioncanvas/confirm-one-way-door"
  };

  const APP_STATE = {
    lastRequestId: null,
    lastOneWayItems: []
  };

  const paletteRoutes = [
    {
      id: "RIU-001",
      name: "Convergence & Scope Clarification",
      keywords: ["clarify", "unclear", "scope", "direction", "where do i start", "confused", "alignment"],
      agent: "Yuty (Narrative) -> Rex (Architecture)",
      artifact: "Convergence Brief",
      action: "Define target outcome, non-goals, and first success metric."
    },
    {
      id: "RIU-014",
      name: "Business Planning & Positioning",
      keywords: ["business plan", "strategy", "positioning", "roadmap", "model", "offer", "pricing"],
      agent: "Rex (Architecture) + Yuty (Narrative)",
      artifact: "Operating Plan v1",
      action: "Build a one-page strategy, priorities, and 30-day execution plan."
    },
    {
      id: "RIU-028",
      name: "Market Signal & Brand Narrative",
      keywords: ["brand", "podcast", "drop", "campaign", "marketing", "audience", "content", "story"],
      agent: "Argy (Research) -> Yuty (Narrative)",
      artifact: "Go-To-Market Brief",
      action: "Map competitors, audience signals, and narrative hooks."
    },
    {
      id: "RIU-039",
      name: "Funding & Grants",
      keywords: ["grant", "funding", "loan", "application", "capital", "subsidy", "government"],
      agent: "Argy (Research) + Theri (Build)",
      artifact: "Funding Pipeline + Draft Applications",
      action: "Generate funding list, eligibility matrix, and first application draft."
    },
    {
      id: "RIU-062",
      name: "Build & Implementation",
      keywords: ["build", "website", "app", "automation", "system", "implement", "launch"],
      agent: "Theri (Build) with Rex (Architecture)",
      artifact: "Implementation Spec + Build Tasks",
      action: "Convert plan into build tickets and delivery sequence."
    },
    {
      id: "RIU-073",
      name: "Debug & Recovery",
      keywords: ["bug", "error", "broken", "issue", "fix", "not working", "failure"],
      agent: "Raptor (Debug)",
      artifact: "Root-Cause + Fix Plan",
      action: "Identify failure point and define minimal corrective action."
    }
  ];

  function scoreRoute(input, route) {
    const text = input.toLowerCase();
    let score = 0;
    for (const keyword of route.keywords) {
      if (text.includes(keyword)) {
        score += keyword.includes(" ") ? 2 : 1;
      }
    }
    return score;
  }

  function chooseLocalRoute(payload) {
    const fullText = [payload.question, payload.context, payload.outcome, payload.constraints].join(" ");
    let best = paletteRoutes[0];
    let bestScore = -1;

    for (const route of paletteRoutes) {
      const s = scoreRoute(fullText, route);
      if (s > bestScore) {
        best = route;
        bestScore = s;
      }
    }

    if (bestScore <= 0) {
      return {
        id: "RIU-001",
        name: "Convergence & Scope Clarification",
        agent: "Yuty (Narrative) -> Rex (Architecture)",
        artifact: "Convergence Brief",
        action: "Clarify objective, constraints, and first measurable output.",
        why: "No strong keyword match. Defaulting to convergence-first routing."
      };
    }

    return {
      ...best,
      why: "Matched route signals in your question and context."
    };
  }

  function detectOneWayDoor(payload) {
    const text = [payload.question, payload.context, payload.outcome, payload.constraints].join(" ").toLowerCase();
    const oneWayTerms = ["production deploy", "delete database", "drop table", "delete data", "irreversible", "migrate live"];
    return oneWayTerms.some((t) => text.includes(t));
  }

  function buildBrief(payload, route) {
    const date = new Date().toISOString().slice(0, 10);
    return [
      "# MissionCanvas Action Brief",
      "",
      `Date: ${date}`,
      `Route: ${route.id} - ${route.name}`,
      `Primary Agent: ${route.agent}`,
      "",
      "## Input",
      `Question: ${payload.question || "N/A"}`,
      `Context: ${payload.context || "N/A"}`,
      `Desired Outcome: ${payload.outcome || "N/A"}`,
      `Constraints: ${payload.constraints || "N/A"}`,
      "",
      "## Immediate Plan",
      `Why this route: ${route.why}`,
      `Next artifact: ${route.artifact}`,
      `Immediate action: ${route.action}`,
      "",
      "## Convergence Checks",
      "- Is the target outcome explicit and measurable?",
      "- Are non-goals defined?",
      "- Is this a ONE-WAY or TWO-WAY decision?",
      "- What is the first deliverable in 24-72 hours?",
      "",
      "Generated by MissionCanvas (OpenClaw integration mode)."
    ].join("\n");
  }

  function makeLocalResponse(payload) {
    const route = chooseLocalRoute(payload);
    const oneWay = detectOneWayDoor(payload);
    const brief = buildBrief(payload, route);

    return {
      request_id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()),
      status: oneWay ? "needs_confirmation" : "ok",
      convergence: {
        complete: Boolean(payload.question && payload.outcome),
        goal: payload.outcome || "UNKNOWN",
        roles: "Human defines intent; agents execute bounded tasks.",
        capabilities: "Argy/Rex/Theri/Raptor/Yuty/Anky/Para",
        constraints: payload.constraints || "None provided",
        non_goals: "Unapproved irreversible actions",
        missing_fields: []
      },
      routing: {
        candidate_rius: [
          {
            riu_id: route.id,
            name: route.name,
            match_strength: "STRONG",
            matched_signals: ["keyword_match"]
          }
        ],
        selected_rius: [
          {
            riu_id: route.id,
            name: route.name,
            why_now: route.why
          }
        ],
        agent_map: [
          {
            agent: route.agent,
            task: route.action,
            maturity: "UNVALIDATED",
            human_required: true
          }
        ]
      },
      one_way_door: {
        detected: oneWay,
        items: oneWay
          ? [
              {
                decision_id: "OWD-001",
                description: "Potential irreversible/production action detected",
                reason: "Policy requires explicit human confirmation.",
                requires_confirmation: true
              }
            ]
          : []
      },
      artifacts: {
        to_create: [route.artifact],
        to_update: []
      },
      validation_checks: [
        "Verify convergence completeness",
        "Confirm decision reversibility",
        "Validate first artifact quality"
      ],
      action_brief_markdown: brief,
      decision_log_payload: `Route=${route.id}; Agent=${route.agent}; OWD=${oneWay}`,
      knowledge_gap: {
        detected: false,
        what_is_missing: [],
        required_retrieval: []
      }
    };
  }

  async function routeViaOpenClaw(payload) {
    const body = {
      request_id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()),
      timestamp: new Date().toISOString(),
      session_id: "missioncanvas-web-session",
      user: { id: "web-user", role: "operator" },
      input: {
        objective: payload.question,
        context: payload.context,
        desired_outcome: payload.outcome,
        constraints: payload.constraints,
        risk_posture: "medium"
      },
      policy: {
        enforce_convergence: true,
        enforce_one_way_gate: true,
        max_selected_rius: 5,
        require_validation_checks: true
      },
      runtime: {
        mode: "planning",
        allow_execution: false,
        tool_whitelist: ["research", "planning"],
        log_target: "implementation"
      }
    };

    const base = CONFIG.apiBase || "";
    const endpoint = `${base}${CONFIG.routePath}`;

    try {
      const res = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      return await res.json();
    } catch (_error) {
      return makeLocalResponse(payload);
    }
  }

  function renderRoutingResponse(response, uiRefs) {
    const selected = (response.routing && response.routing.selected_rius && response.routing.selected_rius[0]) || null;
    const agentMap = (response.routing && response.routing.agent_map && response.routing.agent_map[0]) || null;

    uiRefs.rSource.textContent = response.source || "unknown";
    uiRefs.rStatus.textContent = response.status || "unknown";
    uiRefs.rRiu.textContent = selected ? `${selected.riu_id} - ${selected.name}` : "UNKNOWN";
    uiRefs.rAgent.textContent = agentMap ? agentMap.agent : "UNKNOWN";
    uiRefs.rWhy.textContent = selected ? selected.why_now : "No route details returned.";
    uiRefs.rArtifact.textContent =
      response.artifacts && response.artifacts.to_create && response.artifacts.to_create.length
        ? response.artifacts.to_create.join(", ")
        : "None";

    if (response.status === "needs_confirmation") {
      uiRefs.rAction.textContent = "ONE-WAY DOOR detected. Human confirmation required before execution.";
      uiRefs.confirmOwd.classList.remove("hidden");
      APP_STATE.lastRequestId = response.request_id || null;
      APP_STATE.lastOneWayItems = (response.one_way_door && response.one_way_door.items) || [];
    } else if (agentMap && agentMap.task) {
      uiRefs.rAction.textContent = agentMap.task;
      uiRefs.confirmOwd.classList.add("hidden");
      APP_STATE.lastRequestId = response.request_id || null;
      APP_STATE.lastOneWayItems = [];
    } else {
      uiRefs.rAction.textContent = "Proceed with convergence and first artifact.";
      uiRefs.confirmOwd.classList.add("hidden");
    }

    uiRefs.briefOutput.value = response.action_brief_markdown || "No brief returned.";
    uiRefs.result.classList.remove("hidden");
    uiRefs.result.scrollIntoView({ behavior: "smooth", block: "start" });
  }

  function initAskForm() {
    const form = document.getElementById("askForm");
    if (!form) return;

    const uiRefs = {
      result: document.getElementById("askResult"),
      rRiu: document.getElementById("rRiu"),
      rSource: document.getElementById("rSource"),
      rStatus: document.getElementById("rStatus"),
      rAgent: document.getElementById("rAgent"),
      rWhy: document.getElementById("rWhy"),
      rArtifact: document.getElementById("rArtifact"),
      rAction: document.getElementById("rAction"),
      briefOutput: document.getElementById("briefOutput"),
      confirmOwd: document.getElementById("confirmOwd")
    };

    const copyBtn = document.getElementById("copyBrief");
    const emailBtn = document.getElementById("emailBrief");
    const speakBtn = document.getElementById("speakBrief");
    let currentBrief = "";

    form.addEventListener("submit", async function (e) {
      e.preventDefault();
      const data = new FormData(form);
      const payload = {
        question: String(data.get("question") || "").trim(),
        context: String(data.get("context") || "").trim(),
        outcome: String(data.get("outcome") || "").trim(),
        constraints: String(data.get("constraints") || "").trim()
      };

      const response = await routeViaOpenClaw(payload);
      currentBrief = response.action_brief_markdown || "";
      renderRoutingResponse(response, uiRefs);
    });

    copyBtn.addEventListener("click", async function () {
      if (!currentBrief) return;
      try {
        await navigator.clipboard.writeText(currentBrief);
        copyBtn.textContent = "Copied";
        setTimeout(function () {
          copyBtn.textContent = "Copy Brief";
        }, 1200);
      } catch (_err) {
        copyBtn.textContent = "Copy failed";
      }
    });

    emailBtn.addEventListener("click", function () {
      if (!currentBrief) return;
      const subject = encodeURIComponent("MissionCanvas Routed Brief");
      const body = encodeURIComponent(currentBrief);
      window.location.href = `mailto:hello@missioncanvas.ai?subject=${subject}&body=${body}`;
    });

    uiRefs.confirmOwd.addEventListener("click", async function () {
      if (!APP_STATE.lastRequestId || !APP_STATE.lastOneWayItems.length) return;
      const base = CONFIG.apiBase || "";
      const endpoint = `${base}${CONFIG.confirmPath}`;
      const payload = {
        request_id: APP_STATE.lastRequestId,
        confirmation_id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()),
        approvals: APP_STATE.lastOneWayItems.map((item) => ({
          decision_id: item.decision_id,
          approved: true,
          approved_by: "web-user",
          timestamp: new Date().toISOString(),
          notes: "Confirmed from MissionCanvas web UI"
        }))
      };

      try {
        const res = await fetch(endpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        uiRefs.rStatus.textContent = `${data.status || "approved"} (confirmed)`;
        uiRefs.rAction.textContent = "ONE-WAY DOOR confirmed. Continue with controlled execution.";
        uiRefs.confirmOwd.classList.add("hidden");
      } catch (_err) {
        uiRefs.rAction.textContent = "Confirmation failed. Retry or switch to manual approval flow.";
      }
    });

    speakBtn.addEventListener("click", function () {
      if (!currentBrief || !window.speechSynthesis) return;
      window.speechSynthesis.cancel();
      const utter = new SpeechSynthesisUtterance(currentBrief.slice(0, 900));
      utter.rate = 1.0;
      utter.pitch = 1.0;
      window.speechSynthesis.speak(utter);
    });
  }

  function initHeroAsk() {
    const form = document.getElementById("heroAskForm");
    const heroInput = document.getElementById("heroQuestion");
    if (!form || !heroInput) return;

    const tags = document.querySelectorAll(".tag[data-q]");
    tags.forEach(function (tag) {
      tag.addEventListener("click", function () {
        heroInput.value = tag.getAttribute("data-q") || "";
        heroInput.focus();
      });
    });

    form.addEventListener("submit", function (e) {
      e.preventDefault();
      const askQuestion = document.getElementById("question");
      if (askQuestion) {
        askQuestion.value = heroInput.value.trim();
      }
      const askSection = document.getElementById("ask");
      if (askSection) {
        askSection.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    });
  }

  function initVoiceInput() {
    const voiceStart = document.getElementById("voiceStart");
    const voiceStop = document.getElementById("voiceStop");
    const voiceStatus = document.getElementById("voiceStatus");
    const questionInput = document.getElementById("question");

    if (!voiceStart || !voiceStop || !voiceStatus || !questionInput) return;

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      voiceStatus.textContent = "Voice: not supported in this browser";
      voiceStart.disabled = true;
      voiceStop.disabled = true;
      return;
    }

    const recognition = new SpeechRecognition();
    recognition.lang = "en-US";
    recognition.continuous = true;
    recognition.interimResults = true;

    let finalText = "";

    recognition.onstart = function () {
      voiceStatus.textContent = "Voice: listening";
    };

    recognition.onresult = function (event) {
      let interim = "";
      for (let i = event.resultIndex; i < event.results.length; i += 1) {
        const transcript = event.results[i][0].transcript;
        if (event.results[i].isFinal) {
          finalText += transcript + " ";
        } else {
          interim += transcript;
        }
      }
      questionInput.value = (finalText + interim).trim();
    };

    recognition.onerror = function () {
      voiceStatus.textContent = "Voice: error";
    };

    recognition.onend = function () {
      voiceStatus.textContent = "Voice: idle";
    };

    voiceStart.addEventListener("click", function () {
      try {
        finalText = questionInput.value ? questionInput.value + " " : "";
        recognition.start();
      } catch (_err) {
        voiceStatus.textContent = "Voice: unavailable";
      }
    });

    voiceStop.addEventListener("click", function () {
      recognition.stop();
      voiceStatus.textContent = "Voice: stopped";
    });
  }

  function initWaitlist() {
    const form = document.getElementById("waitlistForm");
    if (!form) return;

    form.addEventListener("submit", function (e) {
      e.preventDefault();
      const data = new FormData(form);
      const name = data.get("name") || "";
      const email = data.get("email") || "";
      const goal = data.get("goal") || "";

      const subject = encodeURIComponent("MissionCanvas Waitlist Request - " + name);
      const body = encodeURIComponent("Name: " + name + "\n" + "Email: " + email + "\n\n" + "Goal:\n" + goal + "\n");

      window.location.href = "mailto:hello@missioncanvas.ai?subject=" + subject + "&body=" + body;
    });
  }

  initAskForm();
  initHeroAsk();
  initVoiceInput();
  initWaitlist();
})();
